using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace LocksContinued.Skiplists
{
    //Теперь обратим внимание на параллельные структуры поиска с логарифмической глубиной
    //SkipList - это набор отсортированных связанных списков, 
    //который тонким образом имитирует сбалансированное дерево поиска. 
    //Узлы в SkipList упорядочены по ключу. Каждый узел связан в подмножество списков. 
    //Каждый список имеет уровень от 0 до максимального. Список нижнего уровня содержит все узлы, 
    //и каждый список более высокого уровня является подсписком списков нижнего уровня. 
    //Можно найти узел с данным ключом, сначала просматривая списки на более высоких уровнях, 
    //пропуская большое количество нижних узлов, и постепенно снижаясь, пока узел с целевым ключом не будет 
    //найден (или нет) на нижнем уровне. SkipList - это вероятностная структура данных. 
    //(Никто не знает, как обеспечить такую ​​производительность без рандомизации.) 
    //Каждый узел создается со случайным верхним уровнем (topLevel) и принадлежит ко всем спискам вплоть до 
    //этого уровня. Верхние уровни выбираются таким образом, чтобы ожидаемое количество узлов в списке 
    //каждого уровня экспоненциально уменьшалось. 
    //Обеспечивая свойство балансировки, подобное классическим последовательным древовидным структурам поиска, 
    //за исключением необходимость сложной глобальной перестройки. Мы помещаем начальные и хвостовые сторожевые 
    //узлы в начало и конец списков с максимально допустимой высотой. Первоначально, когда SkipList пуст, 
    //голова (левый страж) является предшественником хвоста (правого стража) на каждом уровне. 
    //Ключ головы меньше любого ключа, который может быть добавлен к набору, а ключ хвоста больше.
    //Следующее поле каждого узла SkipList представляет собой массив ссылок, по одной для каждого списка, 
    //к которому он принадлежит, и поэтому поиск узла означает поиск его предшественников и преемников. 
    //Поиск SkipList всегда начинается с головы. Метод find ()
    //переходят вниз по уровням один за другим и пересекают каждый уровень, как в LazyList, 
    //используя ссылки на предшествующий узел pred и текущий узел curr.Всякий раз, 
    //когда он находит узел с большим или совпадающим ключом, он записывает pred и curr как предшественника и преемника узла в массивах, 
    //называемых preds [] и succs [], и переходит на следующий более низкий уровень.
    //Обход заканчивается на нижнем уровне.
    public class LazySkipList<T>
    {
        Random r = new Random();

        const int MAX_LEVEL = 42; //максимальный уровень
        Node<T> head = new Node<T>(int.MinValue); //левый столбик - голова
        Node<T> tail = new Node<T>(int.MaxValue); //правый столбик - хвост
        public LazySkipList()
        {
            for (int i = 0; i < head.Next.Length; i++)
            {
                head.Next[i] = tail; //указатели всех нод головы ссылаются на хвост (столбик)
            }
        }

        int Find(T x, Node<T>[] preds, Node<T>[] succs)
        {
            int key = x.GetHashCode(); //берем у ключа хэш
            int lFound = -1; //предварительный результат = не найден уровень
            Node<T> pred = head; //сохраняем в предыдущий столбик голову
            for (int level = MAX_LEVEL; level >= 0; level--) //ходим по всем уровням вниз
            {
                Node<T> curr = Volatile.Read(ref pred.Next[level]); // считываем в текущий, следующий у предыдущего
                while (key > curr.Key) //пока ключ искомый меньше ключа текущего
                {
                    //двигаемся по элементам уровня (слева направо)
                    pred = curr; curr = pred.Next[level]; 
                }
                if (lFound == -1 && key == curr.Key) //если результат был не найден и ключ равен текущему ключу
                {
                    lFound = level; //первый уровень на котором нашли запоминаем (от верхнего к нижнему)
                }
                preds[level] = pred; //сохраняем в массив предыдущих в позицию уровень, предыдущий перед искомым 
                succs[level] = curr; //сохраняем в массив удачных в позицию уровень, текущий элемент
            }
            return lFound; //возвращаем уровень на котором нашли
        }

        public bool Add(T x)
        {
            int topLevel = r.Next(MAX_LEVEL); // количество уровней выбирается случайно, 
            //но должно экспоненциально уменьшатся число элементов на каждом 

            Node<T>[] preds = new Node<T>[MAX_LEVEL + 1]; //массив предыдущих нод
            Node<T>[] succs = new Node<T>[MAX_LEVEL + 1]; //массив удачных
            while (true)// бесконечный цикл
            {
                int lFound = Find(x, preds, succs); //ищем уровень на которо есть элемент
                if (lFound != -1) //если он не -1, значит элемент есть
                {
                    Node<T> nodeFound = succs[lFound]; //сохраняем найденную ноду
                    if (!nodeFound.Marked) //если она не отмечена
                    {
                        while (!nodeFound.FullyLinked) { } //ждем пока она не будет полностью связана
                        return false; //возвращаем, что не добавили
                    }
                    continue; //если помечена, пробуем еще раз бесконечный цикл с начала
                }
                //если элемент не найден
                int highestLocked = -1; //высочайшая блокировка 
                try
                {
                    Node<T> pred, succ; //вводим ноды предыдущий и успешный
                    bool valid = true; //флаг валидности
                    for (int level = 0; valid && (level <= topLevel); level++) //гуляем с 0 уровня до последнего
                    {
                        pred = preds[level]; //в предыдущий кладется значение из массива предвдущих по текущему уровню
                        succ = succs[level]; //в успешный из массива успешных по индексу уровня
                        pred.Lock();//блокируем предыдущий
                        highestLocked = level; //устанавливаем уровень блокировки на текущий, куда пишем
                        valid = !pred.Marked && !succ.Marked && pred.Next[level] == succ;
                        //меняем флаг валидности на = предудущий не отмечен на удаление 
                        //И успешный не отмечен на удаление  И предыдущий на текущем уровне ссылается на успешный
                    }
                    if (!valid) continue; //если где-то не провалидировалось, что никто не залез и не поменял, 
                    //идем в начало бесконечного цикла
                    //иначе
                    Node<T> newNode = new Node<T>(x, topLevel); //создаем новую ноду со значением x и верхним уровнем
                    for (int level = 0; level <= topLevel; level++)
                        newNode.Next[level] = succs[level]; //все следующие у новой ноды направляем на успешный на всех уровнях
                    for (int level = 0; level <= topLevel; level++)
                        preds[level].Next[level] = newNode; //все указалели на каждом уровне для следующего у предыдущего 
                    //направляем на нашу новую ноду
                    newNode.FullyLinked = true; //говорим о том, что элемент добавился на всех уровнях
                    return true;//возврашаем
                }
                finally
                {
                    for (int level = 0; level <= highestLocked; level++)
                        preds[level].Unlock(); //разблокируем все предыдущие на всех уровнях до наивысшего куда записывали
                }
            }
        }

        bool Remove(T x)
        {
            Node<T> victim = null; //нода жертва для удаления
            bool isMarked = false; //отметка на удаление первоначально фолз
            int topLevel = -1; //верхний уровень
            Node<T>[] preds = new Node<T>[MAX_LEVEL + 1]; //создаем столбик предыдущих
            Node<T>[] succs = new Node<T>[MAX_LEVEL + 1]; //столбик удачных
            while (true) //бесконечный цикл
            {
                int lFound = Find(x, preds, succs); //находим уровень и предыдущие и успешные
                if (lFound != -1) victim = succs[lFound]; //если элемент найден, то жертвой нахначаем успешный с индексом первого уровня
                if (isMarked ||
                (lFound != -1 &&
                (victim.FullyLinked
                 && victim.TopLevel == lFound
                 && !victim.Marked)))
                 //если отметка на удаление ИЛИ (элемент найден И верхний уровень жертвы соответствует найденному И жертва не помечена)
                {
                    if (!isMarked) //если нет отметки
                    {
                        topLevel = victim.TopLevel; //запоминаем верхний уровень жертвы
                        victim.Lock(); //блокируем ее
                        if (victim.Marked) //если жертва отмечена на удаление
                        {
                            victim.Unlock();//снимаем блокировку
                            return false;//говорим, что не удалили, кто-то сделал за нас
                        }
                        //иначе
                        victim.Marked = true; //отмечаем жертву как удаляему
                        isMarked = true; //делаем пометку об удалении с верхнего уровня
                    }
                    int highestLocked = -1; //высочайшая блокировка
                    try
                    {
                        Node<T> pred, succ; //объявляем текущий и предыдущий
                        bool valid = true; //флаг валидации
                        for (int level = 0; valid && (level <= topLevel); level++) //гуляем по уровням пока флаг валидации и уровень <= максимума
                        {
                            pred = preds[level]; //в предыдущий сохраняем предыдущий на текущем уровне
                            pred.Lock(); //берем на него блокировку
                            highestLocked = level; //устанавливаем высочайший уровень в текущий
                            valid = !pred.Marked && pred.Next[level] == victim; 
                            //флаг валидации, предыущий должен быть не помечен на удаление, а следующий у него, это жертва
                            //кто то что-то поменял, если фолз
                        }
                        if (!valid) continue; //если валидация не прошла, возвращаемся в начало цикла
                        for (int level = topLevel; level >= 0; level--) //ходим по всем уровням с верхнего
                        {
                            preds[level].Next[level] = victim.Next[level]; 
                            //перекидываем указатель с предыдущего на уровне на следующий у жертвы на том же уровне
                        }
                        victim.Unlock(); //разблокируем жертву
                        return true; //говорим, что успешно удалили
                    }
                    finally
                    {
                        for (int i = 0; i <= highestLocked; i++)
                        {
                            preds[i].Unlock(); //снимаем блокировку со всех предыдущих
                        }
                    }
                }
                else return false; //иначе возвращаем, что не удалили
            }
        }

        public bool Contains(T x)
        {
            Node<T>[] preds = new Node<T>[MAX_LEVEL + 1]; //создаем столбик предыдущих
            Node<T>[] succs = new Node<T>[MAX_LEVEL + 1]; //создаем столбик успешных
            int lFound = Find(x, preds, succs); //получаем верхний уровень, на котором есть элемент
            return (lFound != -1
                && succs[lFound].FullyLinked
                && !succs[lFound].Marked); 
            //возвращаем тру если уровень не -1 И он полностью построен И он не отмечен на удаление
        }

        private class Node<T>
        {
            Mutex _lock = new Mutex(); //блокировка
            public T item; //хранимое значение
            public int Key; //ключ
            public Node<T>[] Next; //указатель на следующий массив нод
            public volatile bool Marked = false; //пометка на удаление
            public volatile bool FullyLinked = false; //пометка полной сязанности (добавлен на всех узлах)
            public int TopLevel; //номер верхнего уровня
            public Node(int key)
            { // конструктор сентинелов
                this.item = default(T); //значение по умолчанию
                this.Key = key; //переданный ключ
                Next = new Node<T>[MAX_LEVEL + 1]; //следующий это массив нод
                TopLevel = MAX_LEVEL; //верхний уровень = макимальный уровень
            }
            public Node(T x, int height)
            {
                item = x; //хранимое значение
                Key = x.GetHashCode(); //ключ - хэш значения
                Next = new Node<T>[height + 1]; //массив нод размерности высота + 1
                TopLevel = height; //верхний уровень = высота
            }
            public void Lock() {
                _lock.WaitOne(); //взять блокировку на ноду
            }
            public void Unlock()
            {
                _lock.ReleaseMutex(); //отпустить блокировку на ноду
            }
        }
    }
}
